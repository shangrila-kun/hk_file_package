- 算法的复杂性描述

  > 由于算法的O复杂性给出了算法的实际复杂度的*上限*，而Θ给出了算法的实际复杂度，我们有时会说Θ给了我们一个*紧密的界限*。如果我们知道我们已经发现复杂度不太紧的话，我们也可以用小写的o来表示这个。例如，如果算法是Θ（n），那么它的紧密复杂度是n。那么这个算法既是O（n）又是O（n 2）。由于该算法是Θ（n），O（n）边界是紧密的。但是O（n 2）的界限并不紧密，所以我们可以写出算法是o（n 2）），这是发音“n平方小”，以说明我们知道我们的约束不紧。如果我们能够找到我们算法的紧密边界，那么会更好，因为这些给我们提供了有关我们的算法如何表现的更多信息，但这并不容易。

  - 递归复杂性

  > 现在我们来看一个递归函数。一个*递归函数*是调用自身的函数。让我们分析一下这个函数的复杂性。这个函数没有任何循环，但其复杂性也不是常量。我们需要做的就是找出它的复杂性，然后再去计算指令。显然，如果我们将n传递给这个函数，它会执行n次。如果你对此不确定，现在运行n = 5来验证它是否真正起作用。例如，对于n = 5，它将执行5次，因为它会在每次调用中将n减1。因此我们可以看到这个函数是Θ（n）。

  - 对数复杂度

  > 计算机科学中的一个着名问题是在数组内搜索一个值。我们早些时候为一般情况解决了这个问题。如果我们有一个已排序的数组并且我们想要在其中找到给定值，那么这个问题就变得有趣了。一种方法就是*二进制搜索*。我们看看我们数组的中间元素：如果我们发现它，我们就完成了。否则，如果我们发现的值比我们要查找的值大，我们知道我们的元素将位于数组的左边。否则，我们知道它将在数组的右侧。我们可以继续将这些较小的阵列切成两半，直到我们有一个单独的元素可以查看。
  >
  > ​

请参阅**图6**以帮助您了解二分法搜索的运作方式。

如果您不确定此方法是否有效，请立即花一点时间用一个简单的示例手动运行它，并说服自己确实可行。

现在让我们尝试分析这个算法。同样，在这种情况下我们有一个递归算法。为简单起见，我们假设数组总是被精简为一半，而忽略递归调用中的+1和-1部分。现在你应该确信，一点点改变，比如忽略+ 1和-1不会影响我们的复杂性结果。这是一个事实，我们通常必须证明我们是否希望从数学的角度来看是谨慎的，但实际上它是直观明显的。为了简单起见，我们假设我们的数组的大小精确到2。这个假设再一次不会改变我们将要到达的复杂性的最终结果。对于这个问题，最糟糕的情况会发生在我们要查找的值完全不在我们的数组中。在那种情况下，d在递归的第一次调用中从一个大小为n的数组开始，然后在下一次调用中获得大小为n / 2的数组。然后我们会在下一次递归调用中得到一个大小为n / 4的数组，然后是一个大小为n / 8的数组，等等。一般来说，我们的数组在每次调用时都会被分成两半，直到达到1.所以，让我们在每次调用时都写入数组中的元素数量：

1. 第 0 次迭代：n
2. 第一次迭代：n / 2
3. 2 次迭代：N / 4
4. 第3 次迭代：n / 8
5. ...
6. 第 i 次迭代：n / 2 i
7. ...
8. 最后一次迭代：1

请注意，在第i次迭代中，我们的数组有n / 2个i元素。这是因为在每次迭代中我们都将我们的数组减半，这意味着我们将其元素数量除以2。这意味着将分母乘以2.如果我们这样做，我们得到n / 2 i。现在，这个过程继续下去，每增加一个，我们就会得到更少的元素，直到我们到达最后一次迭代时，我们只剩下1个元素。如果我们希望找到我看到这将发生什么迭代，我们必须解出下面的等式：

1 = n / 2 i

当我们到达binarySearch（）函数的最终调用时，这只会是真的，而不是在一般情况下。所以在这里解决我将帮助我们找到递归在哪个迭代中完成。双方乘以2 我得到：

2 i = n

现在，如果你阅读上面的对数部分，这个方程应该看起来很熟悉。为我解决我们有：

i = log（n）

这告诉我们执行二进制搜索所需的迭代次数是log（n），其中n是原始数组中元素的数量。

如果你考虑一下，这是有道理的。例如，取n = 32，一个由32个元素组成的数组。我们有多少次需要减少一半才能获得1个元素？我们得到：32→16→8→4→2→1。我们做了5次，这是32的对数。因此，二进制搜索的复杂度是Θ（log（n））。

最后的结果使我们能够比较二分查找和线性查找，这是我们以前的方法。显然，由于log（n）比n小得多，所以有理由得出结论：二元搜索是一种在数组内进行搜索然后进行线性搜索的更快的方法，所以如果我们想要做的话保持数组的排序可能是明智的许多搜索内容。